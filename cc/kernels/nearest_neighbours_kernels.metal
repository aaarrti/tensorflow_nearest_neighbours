#include <metal_stdlib>thread int16_t index_2d_flat(const thread int16_t& index_0, const thread int16_t& index_1, constant int16_t& shape_1) {  return index_1 + index_0 * shape_1;}thread int16_t index_3d_flat(const thread int16_t& index_0, const thread int16_t& index_1,                             thread int16_t& index_2, constant int16_t& shape_1, constant int16_t& shape_2) {  return index_2 + index_1 * shape_2 + index_0 * shape_2 * shape_1;}kernel void NearestNeighboursMetalKernel(    // inputs    constant half* token_embeddings,    constant half* embedding_matrix,    // output    device half* outputs,    // attributes    constant int16_t& sequence_length,    constant int16_t& vocab_size,    constant int16_t& embed_dim,    // thread id    uint2 tid [[thread_position_in_grid]]) {  const thread int16_t index_in_batch = tid[0];  const thread int16_t index_in_sequence = tid[1];  half min_dist = 100;  int16_t argmin = 0;  for (thread int16_t word_index = 0; word_index != vocab_size; word_index++) {    thread half dist = min_dist;    for (thread int16_t i = 0; i != embed_dim; i++) {      const thread int16_t index_in_embedding_matrix = index_2d_flat(word_index, i, embed_dim);      const thread int16_t index_in_token_embeddings = index_3d_flat(index_in_batch, index_in_sequence, i, sequence_length, embed_dim);      const thread half val1 = embedding_matrix[index_in_embedding_matrix];      const thread half val2 = token_embeddings[index_in_token_embeddings];      dist += metal::exp2(val1 - val2);    }    dist = metal::sqrt(dist);    if (dist < min_dist) {      min_dist = dist;      argmin = word_index;    }  }  for (thread int16_t i = 0; i != embed_dim; i++) {    const thread int16_t index_in_output = index_3d_flat(index_in_batch, index_in_sequence, i, sequence_length, embed_dim);    const thread int16_t index_in_embedding_matrix = index_2d_flat(argmin, i, embed_dim);    outputs[index_in_output] = embedding_matrix[index_in_embedding_matrix];  }}